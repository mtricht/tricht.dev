<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=author content="Michael van Tricht"><meta name=description content="At work we use AWS ECS (Amazon EC2 Container Service) for orchestrating our docker containers. We have a rather small
number of containers running (26~) which all log to CloudWatch. Being unsatisfied by the features such as alerting we started looking for a better logging solution."><meta name=keywords content="blog,developer,personal,resume"><meta name=twitter:card content="summary"><meta name=twitter:title content="Using Graylog for logging on Amazon ECS"><meta name=twitter:description content="At work we use AWS ECS (Amazon EC2 Container Service) for orchestrating our docker containers. We have a rather small
number of containers running (26~) which all log to CloudWatch. Being unsatisfied by the features such as alerting we started looking for a better logging solution."><meta property="og:title" content="Using Graylog for logging on Amazon ECS"><meta property="og:description" content="At work we use AWS ECS (Amazon EC2 Container Service) for orchestrating our docker containers. We have a rather small
number of containers running (26~) which all log to CloudWatch. Being unsatisfied by the features such as alerting we started looking for a better logging solution."><meta property="og:type" content="article"><meta property="og:url" content="https://tricht.dev/post/using-graylog-for-logging-on-amazon-ecs/"><meta property="article:published_time" content="2017-06-08T21:29:34+02:00"><meta property="article:modified_time" content="2017-06-08T21:29:34+02:00"><base href=https://tricht.dev/post/using-graylog-for-logging-on-amazon-ecs/><title>Using Graylog for logging on Amazon ECS Â· Michael van Tricht</title><link rel=canonical href=https://tricht.dev/post/using-graylog-for-logging-on-amazon-ecs/><link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.13.0/css/all.css integrity=sha384-Bfad6CLCknfcloXFOyFnlgtENryhrpZCe29RTifKEixXQZ38WheV+i/6YWSzkz3V crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=/css/coder.min.fce3d3684e836ce340cdd591dad1749c310472d5ed4049fab99845c9aec4d4bf.css integrity="sha256-/OPTaE6DbONAzdWR2tF0nDEEctXtQEn6uZhFya7E1L8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.717236c74e0a5208ef73964a9f44c6b443b689a95b270d8b2a40d0c012460dac.css integrity="sha256-cXI2x04KUgjvc5ZKn0TGtEO2ialbJw2LKkDQwBJGDaw=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/extra.css><link rel=icon type=image/png href=https://tricht.dev/images/favicon.ico sizes=32x32><link rel=icon type=image/png href=https://tricht.dev/images/favicon.ico sizes=16x16><link rel=apple-touch-icon href=https://tricht.dev/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=https://tricht.dev/images/apple-touch-icon.png><meta name=generator content="Hugo 0.74.3"></head><body class=colorscheme-dark><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Michael van Tricht</a>
<span id=dark-mode-toggle class=float-right><i class="fas fa-adjust fa-fw"></i></span><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fas fa-bars fa-fw"></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=https://tricht.dev/about/>About</a></li><li class=navigation-item><a class=navigation-link href=https://tricht.dev/post/>Blog</a></li><li class="navigation-item separator"><span>|</span></li></ul></section></nav><div class=content><section class="container page"><article><header><h1>Using Graylog for logging on Amazon ECS</h1></header><p>At work we use <a href=https://aws.amazon.com/ecs/>AWS ECS</a> (Amazon EC2 Container Service) for orchestrating our docker containers. We have a rather small
number of containers running (26~) which all log to <a href=https://aws.amazon.com/cloudwatch/>CloudWatch</a>. Being unsatisfied by the features such as alerting we started looking for a better logging solution.</p><p>We tried numerous LaaS (Logging as a Service), but they all were lacking in one way or another:</p><ul><li>Alerting is hard to configure or non-existing.</li><li>No easy integration with docker (or ECS).</li><li>They are expensive for what they offer.</li><li>Retention of logs is short.</li></ul><p>We ended up choosing <a href=https://www.graylog.org/>Graylog</a> which is a selfhosted logging platform with search (using Elasticsearch), alerts and dashboards. I&rsquo;m not gonna tell you how to set it up, for that there are excellent docs available from Graylog which can be found <a href=http://docs.graylog.org/en/2.2/pages/getting_started.html>here</a>. But I will tell you how we setup our ECS cluster.</p><h2 id=logging-drivers>Logging drivers</h2><p>Docker supports various logging drivers, such as json-file, gelf, syslog and <a href=https://docs.docker.com/engine/admin/logging/overview/#supported-logging-drivers>more</a>. The default logging driver is json-file which simply captures stdout and stderr of a container and puts that in a JSON object with some metadata. Gelf is a format designed and used by Graylog. It&rsquo;s basically a dict with the log message and some metadata that is sent chunked over UDP. Chunked because UDP has a limit of about 65 kilobytes and logs can be quite big (when logging SOAP requests for example). There are two ways to setup Graylog on AWS ECS.</p><p>The first being using the gelf driver and having to add the required gelf-address log option and the optional gelf-compression-type, gelf-compression-level, tag, labels and env log options. This meant we had to edit all of our 26 task definitions, making sure our CI had the correct configuration and making sure task definitions in the future will also have the correct options set.</p><p>This is rather tiresome and there&rsquo;s an easier way of setting this up, which is using the json-file logging driver. But how would you get the logs to Graylog? Well, for that we use <a href=https://github.com/gliderlabs/logspout>logspout</a>. Logspout is a small go application which listens to logs by using <code>docker.sock</code>, appends metadata (such as container name and image name) and sends that to a server. Aside from having less work to do, you&rsquo;re not tied to the gelf protocol. If you&rsquo;d want to change the log server or switch to a different logging solution, you&rsquo;d only have to change the logspout task definition or perhaps replace it with <a href=https://www.elastic.co/products/logstash>logstash</a>.</p><h2 id=setting-up-logspout-on-aws-ecs>Setting up logspout on AWS ECS</h2><p>First make sure all your tasks use the json-file logging driver. Then setup a task definition to run logspout. The following example task definition runs logspout, mounts docker.sock and sends logs to a graylog server with syslog.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:#f92672>&#34;containerDefinitions&#34;</span>: [
    {
      <span style=color:#f92672>&#34;mountPoints&#34;</span>: [
        {
          <span style=color:#f92672>&#34;containerPath&#34;</span>: <span style=color:#e6db74>&#34;/var/run/docker.sock&#34;</span>,
          <span style=color:#f92672>&#34;sourceVolume&#34;</span>: <span style=color:#e6db74>&#34;dockersock&#34;</span>
        }
      ],
      <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;logspout&#34;</span>,
      <span style=color:#f92672>&#34;image&#34;</span>: <span style=color:#e6db74>&#34;gliderlabs/logspout:latest&#34;</span>,
      <span style=color:#f92672>&#34;command&#34;</span>: [
        <span style=color:#e6db74>&#34;udp://graylog.example.org:1514&#34;</span>
      ]
    }
  ],
  <span style=color:#f92672>&#34;volumes&#34;</span>: [
    {
      <span style=color:#f92672>&#34;host&#34;</span>: {
        <span style=color:#f92672>&#34;sourcePath&#34;</span>: <span style=color:#e6db74>&#34;/var/run/docker.sock&#34;</span>
      },
      <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;dockersock&#34;</span>
    }
  ]
}
</code></pre></div><p>A default logspout environment is only able to send logs to a server that accepts syslogs. Graylog is able to receive syslogs but with syslog we can&rsquo;t tell from what container or image a log message came from. With the gelf adapter for logspout you&rsquo;re able to see that information. If you want to send logs over gelf replace the <code>gliderlabs/logspout</code> image with <code>vincit/logspout-gelf</code>, which is an image with a gelf third-party adapter pre-installed. Replace <code>udp://graylog.example.org:1514</code> with <code>gelf://graylog.example.org:1514</code> and you&rsquo;re set. Happy logging!</p></article></section></div><footer class=footer><section class=container></section></footer></main><script src=/js/dark-mode.min.0213e1773e6d1c5a644f847c67a6f8abac49a3776e2976f6008038af8c5b76a1.js></script><script>(function(f,a,t,h,o,m){a[h]=a[h]||function(){(a[h].q=a[h].q||[]).push(arguments)};o=f.createElement('script'),m=f.getElementsByTagName('script')[0];o.async=1;o.src=t;o.id='fathom-script';m.parentNode.insertBefore(o,m)})(document,window,'//analytics.tricht.dev/tracker.js','fathom');fathom('set','siteId','TMBWC');fathom('trackPageview');</script></body></html>